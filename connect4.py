# -*- coding: utf-8 -*-
"""Connect4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f0NKj4PU7rmgsgWIXwaRVyiUdYpVEr3_
"""

class Connect4:
  def __init__(self):
      self.height = 6
      self.width = 7
      self.connect = 4
      self.legal_players = ["X", "O"]
      self.reset()
        
  def reset(self):
      self.board = [[" " for _ in range(self.width)] for _ in range(self.height)]
      
  def __str__(self):
      # String representation of a game
      board = ""
      for r in range(self.height):
          board += "|"
          for c in range(self.width):
              board += "{}|".format(self.board[r][c])
          board += "\n"
      return board[:-1]

game = Connect4()
print(game)

def _is_match(self, match):
    s_match = set(match)
    if len(s_match) == 1 and " " not in s_match:
        return match[0]

def move(self, player, c):
    player = player.upper()
    assert c in self.get_moves(), "Illegal move"
    assert player in self.legal_players, "Illegal player"
    move_row = 0
    for r in reversed(range(self.height)):
        if self.board[r][c] == " ":
            move_row = r
            break
    self.board[move_row][c] = player
    
def winner(self):
    # check horizontal
    for r in range(self.height):
        for c in range(self.width - self.connect + 1):
            match = [self.board[r][c+off] for off in range(self.connect)]
            if self._is_match(match) is not None:
                return match[0]
            
    # check vertical
    for r in range(self.height - self.connect + 1):
        for c in range(self.width):
            match = [self.board[r+off][c] for off in range(self.connect)]
            if self._is_match(match) is not None:
                return match[0]

    # check diagonal 
    for r in range(self.height - self.connect // 2 - 1):
        for c in range(self.width - self.connect // 2 - 1):
            # diagonal \
            match = [self.board[r + off][c + off] for off in range(self.connect)]
            if self._is_match(match) is not None:
                return match[0]
            # diagonal /
            match = [self.board[off][self.width - off - 1] for off in range(self.connect)]
            if self._is_match(match) is not None:
                return match[0]

class Connect4:
  def __init__(self):
      self.height = 6
      self.width = 7
      self.connect = 4
      self.legal_players = ["X", "O"]
      self.reset()
        
  def reset(self):
      self.board = [[" " for _ in range(self.width)] for _ in range(self.height)]
      
  def __str__(self):
      # String representation of a game
      board = ""
      for r in range(self.height):
          board += "|"
          for c in range(self.width):
              board += "{}|".format(self.board[r][c])
          board += "\n"
      return board[:-1]

  def __eq__(self, other):
    if isinstance(other, type(self)):
        return self.board == other.board
    return False

  def __hash__(self):
      return hash("".join(sum(self.board,[])))

  def copy(self):
      # Creates a copy of the game object
      new_board = self.__class__()
      new_board.board = [x[:] for x in self.board]
      return new_board

  def get_moves(self):
      # Check if top row filled
      return [idx for idx, val in enumerate(self.board[0]) if val == " "]

  def _is_match(self, match):
    s_match = set(match)
    if len(s_match) == 1 and " " not in s_match:
        return match[0]

  def move(self, player, c):
      player = player.upper()
      assert c in self.get_moves(), "Illegal move"
      assert player in self.legal_players, "Illegal player"
      move_row = 0
      for r in reversed(range(self.height)):
          if self.board[r][c] == " ":
              move_row = r
              break
      self.board[move_row][c] = player
      
  def winner(self):
      # check horizontal
      for r in range(self.height):
          for c in range(self.width - self.connect + 1):
              match = [self.board[r][c+off] for off in range(self.connect)]
              if self._is_match(match) is not None:
                  return match[0]
              
      # check vertical
      for r in range(self.height - self.connect + 1):
          for c in range(self.width):
              match = [self.board[r+off][c] for off in range(self.connect)]
              if self._is_match(match) is not None:
                  return match[0]

      # check diagonal 
      for r in range(self.height - self.connect // 2 - 1):
          for c in range(self.width - self.connect // 2 - 1):
              # diagonal \
              match = [self.board[r + off][c + off] for off in range(self.connect)]
              if self._is_match(match) is not None:
                  return match[0]
              # diagonal /
              match = [self.board[off][self.width - off - 1] for off in range(self.connect)]
              if self._is_match(match) is not None:
                  return match[0]

  def score_game(self, player):
      if self.winner() == player:
          return 1
      elif self.winner() in self.legal_players:
          return -1
      return 0
  
  def gameover(self):
      return len(self.get_moves()) == 0 or self.winner() is not None

class MinimaxBot:
  def __init__(self, time_penalty = -0.01, sub_optimal_weight = 0.1, limit =5):
    self.time_penalty = time_penalty
    self.memo = {} #saves the best move and score by player and game
    self.sub_optimal_weight = sub_optimal_weight
    self.limit = limit

  def play(self, game, player):
    return self.minimax(game, player)[0]

  def minimax(self, game, player, num_moves=0):
    # Helper function for get_best_move
    # returns best move and score given game and player

    # if player not in memo dictionary, add an empty dict
    if player not in self.memo:
      self.memo[player] = {}
    # set player_memo to what memo has saved for player
    player_memo = self.memo[player]

    # if game is not in player_memo (haven't seen this/searched this state before)
    if game not in player_memo:
        # check if game over, assign best_move and best_score appropriately if necessary
        if game.gameover():
          best_move = None
          best_score = game.score_game(player)
        # check if num_moves is over the depth limit & assign best_move/best_score appropriately if necessary
        elif num_moves > self.limit:
          best_move = game.get_moves()[0]
          best_score = 0
        else:          
        # otherwise:
            # assign alt_player (the other player)
            alt_player = [alt_player for alt_player in game.legal_players if alt_player != player][0]
            # assign moves, the possible moves for this game
            moves = game.get_moves()
            # set best_score to negative infinity (float("-inf"))
            best_score = float('-inf')
            # set sub_optimal_sum to 0
            sub_optimal_sum = 0
            # iterate through moves:
            for move in moves:
                # create and save a copy of the game
                clone = game.copy()
                # make the given move on the clone
                clone.move(player, move)
                # call minimax recursively with alt_player
                best_mover, score = self.minimax(clone, alt_player, num_moves= num_moves +1)
                # get score from minimax call, make it negative
                score *= -1
                # (because a negative score for one player is a positive for the other)
                # and add the time penalty * num_moves
                score += self.time_penalty * num_moves
                # add this score to the sub_optimal_sum
                sub_optimal_sum += score
                # compare score to best score and update best_move/best_score appropriately
                if score > best_score:
                  best_move = move
                  best_score = score
            # remove the best score from the sub-optimal running sum 
            sub_optimal_sum -= best_score
            # average the sub-optimal returns
            sub_optimal = sub_optimal_sum / len(moves)
            # take a weighted average of the perfect and sub-optimal returns based on sub-optimal weight provided
            best_score = ((1 - self.sub_optimal_weight) * best_score) + (self.sub_optimal_weight * sub_optimal)

            # and set it to best_score 
        # update memo for the player and game with the best_move and best_score
        self.memo[player][game] =(best_move, best_score)
    # return memo for the player and game
    return self.memo[player][game]

def play(game, bot):
    human = None
    while human is None:
        human = input("Select player: {} ".format(game.legal_players)).upper()
        if human not in game.legal_players:
            print("Invalid option")
            human = None
            
    comp = [alt_player for alt_player in game.legal_players if alt_player != human][0]
    turn = game.legal_players[0]
    while not game.gameover():    
        if comp == turn:
            move = bot.play(game, comp)
        else:
            print(game)
            move = None
            while move is None:
                move = input("Input move: ")
                if move.upper()[:1] == "Q":
                    print("Quitter...")
                    return
                elif move.upper()[:1] == "H":
                    print(game.__doc__)
                    continue
                if move.isdigit():
                    move = int(move)
        if move in game.get_moves():
            game.move(turn, move)
            turn = comp if turn == human else human
        else:
            print("Illegal move {}. Q to quit. H for help".format(move))
    print(game)
    if game.winner() == human:
        print("You won!")
    elif game.winner() == comp:
        print("You lost :-(")
    else:
        print("It's a draw")

game = Connect4()

game.reset()
play(game, MinimaxBot())