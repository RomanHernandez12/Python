# -*- coding: utf-8 -*-
"""Roman_MiniMaxActivity.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GMhSem7wS9axqd1z23fBbDW8vjeHcKNY
"""

import time

class Game:
  def __init__(self):
    self.initialize_game()

  def initialize_game(self):
    self.current_state = [['.','.','.'],
                          ['.','.','.'],
                          ['.','.','.']]
    self.player_turn = 'X'
  def draw_board(self):
    for i in range(0, 3):
      for j in range(0, 3):
        print('{}|'.format(self.current_state[i][j]), end=" ")
      print()
    print()
  
  def is_valid(self, x_coordinate, y_coordinate):
    #Determine if the move is legal
    if x_coordinate < 0 or x_coordinate > 2 or y_coordinate < 0 or y_coordinate > 2:
      return False
    elif self.current_state[x_coordinate][y_coordinate] != '.':
      return False
    else:
      return True
  
  
  
  def is_end(self):
    #Checks if the game has ended and returns the winner (if any - remember the ties!)
    #Change it such that it returns who won (either X or O)

    #First case: Vertical Win
    
    for i in range(0, 3):
      if(self.current_state[0][i] == self.current_state[1][i] == self.current_state[2][i] and self.current_state[0][i] != '.'):
        return self.current_state[0][i]

    #Fourth Case: Check if there are any empty spaces -> if so, return None
    for i in range(0, 3):
      for j in range(0, 3):
        if(self.current_state[i][j] == '.'):
          return None

    #Second Case: Horizontal Win
    for i in range(0, 3):
      if(self.current_state[i][0] == self.current_state[i][1] == self.current_state[i][2] and self.current_state[0][0] != '.'):
        return self.current_state[i][0]
    #Third Case: One Diagonal (Upper Left to Bottom Right)
    if(self.current_state[0][0] == self.current_state[1][1] == self.current_state[2][2] and self.current_state[0][0] != '.'):
      return self.current_state[0][0]

    #Last Diagonal
    if(self.current_state[0][2] == self.current_state[1][1] == self.current_state[2][0] and self.current_state[0][2] != '.'):
      return self.current_state[0][2] 

    return '.'
  

  def max(self):
    #In our game, the AI is going to be max -> we are going to be min. The AI is going to want to maximize its own winning while minimizing ours
    #It will be player 'O'
    #First, we have three variables: maxv (the max value), x_coor, y_coor

    #Set maxv = -2 and initialize coordinates to None
    maxv = -2
    x_coor = None
    y_coor = None
    #FIRST STEP: Find the current step of the board(who won, is the board still empty etc.)
    result = self.is_end()
    #(1, 0, 0) #Indicates Win
    #(-1, 0, 0) #Indicates Loss
    #(0, 0, 0) #Tie
    if result == 'X':
      return (-1, 0, 0)
    elif result == 'O':
      return (1, 0, 0)
    elif result == '.':
      return (0, 0, 0) 
    #SECOND STEP: Loop through all of the empty spots of the board, and place a 'O' in the empty space to find the move that gets you the maximum value
    for i in range(0, 3):
      for j in range(0, 3):
        if self.current_state[i][j] == '.':
          self.current_state[i][j] = 'O'
          #HERE WE CALL MIN
          (m, min_i, min_j) = self.min()
          if m > maxv:
            maxv = m
            x_coor = i
            y_coor = j
          self.current_state[i][j] = '.'

    return (maxv, x_coor, y_coor)
  
  def min(self):
    #Minv, x_min, y_min
    minv = 2
    x_min = None
    y_min = None
    result = self.is_end()
    if result == 'X':
      return (-1, 0, 0)
    elif result == 'O':
      return (1, 0, 0)
    elif result == '.':
      return (0, 0, 0)

    for i in range(0, 3):
      for j in range(0, 3):
        if self.current_state[i][j] == '.':
          self.current_state[i][j] = 'X'
          (m, max_i, max_j) = self.max()
          if m < minv:
            minv = m
            x_min = i
            y_min = j
          self.current_state[i][j] = '.'

    return (minv, x_min, y_min)
  

  def play(self):
      while True:
        self.draw_board()
        self.result = self.is_end()
        print(self.result)
        if self.result != None:
          if self.result == 'X':
            print('The winner is X!')
          elif self.result == 'O':
            print('The winner is O!')
          elif self.result == '.':
            print("It's a tie!")

          self.initialize_game()
          return

        # if it is the human player's turn
        if self.player_turn == 'X':
          while True:
            start = time.time()
            (m, qx, qy) = self.min()
            print('Recommended move: X = {}, Y = {}'.format(qx, qy))
            end = time.time()
            print("Evaluation time: {}s".format(round(end - start, 7)))
            px = int(input('Insert the X coordinate: '))
            py = int(input('Insert the Y coordinate: '))

            (qx, qy) = (px, py)

            if self.is_valid(px, py):
              self.current_state[px][py] = 'X'
              self.player_turn = 'O'
              break
            else:
              print('The move is not valid! Try again.')

        # if it's the AI's turn
        else:
          (m, px, py) = self.max()
          self.current_state[px][py] = 'O'
          self.player_turn = 'X'

g =  Game()
g.play()

#Next step: Implementing the alpha beta pruning process and note the time it takes to do each

def max_alpha_beta(self, alpha, beta):
  #In our game, the AI is going to be max -> we are going to be min. The AI is going to want to maximize its own winning while minimizing ours
    #It will be player 'O'
    #First, we have three variables: maxv (the max value), x_coor, y_coor

    #Set maxv = -2 and initialize coordinates to None
    maxv = -2
    x_coor = None
    y_coor = None
    #FIRST STEP: Find the current step of the board(who won, is the board still empty etc.)
    result = self.is_end()
    #(1, 0, 0) #Indicates Win
    #(-1, 0, 0) #Indicates Loss
    #(0, 0, 0) #Tie
    if result == 'X':
      return (-1, 0, 0)
    elif result == 'O':
      return (1, 0, 0)
    elif result == '.':
      return (0, 0, 0) 
    #SECOND STEP: Loop through all of the empty spots of the board, and place a 'O' in the empty space to find the move that gets you the maximum value
    for i in range(0, 3):
      for j in range(0, 3):
        if self.current_state[i][j] == '.':
          self.current_state[i][j] = 'O'
          #HERE WE CALL MIN
          (m, min_i, min_j) = self.min_alpha_beta(alpha, beta)
          if m > maxv:
            maxv = m
            x_coor = i
            y_coor = j
          self.current_state[i][j] = '.'

          #Two if statements = only difference
          if maxv >= beta:
            return (maxv, x_coor, y_coor)
          
          if maxv > alpha:
            alpha = maxv
    return (maxv, x_coor, y_coor)

def min_alpha_beta(self, alpha, beta):
    #Minv, x_min, y_min
    minv = 2
    x_min = None
    y_min = None
    result = self.is_end()
    if result == 'X':
      return (-1, 0, 0)
    elif result == 'O':
      return (1, 0, 0)
    elif result == '.':
      return (0, 0, 0)

    for i in range(0, 3):
      for j in range(0, 3):
        if self.current_state[i][j] == '.':
          self.current_state[i][j] = 'X'
          (m, max_i, max_j) = self.max_alpha_beta(alpha, beta)
          if m < minv:
            minv = m
            x_min = i
            y_min = j
          self.current_state[i][j] = '.'

          if minv <= alpha:
            return (minv, x_min, y_min)

          if minv < beta:
            beta = minv

    return (minv, x_min, y_min)

class Game_AB:
  # call initialize game method
  def __init__(self):
    self.initialize_game()

  # initialize game to the starting state of an empty board
  def initialize_game(self):
    self.current_state = [['.','.','.'],
                          ['.','.','.'],
                          ['.','.','.']]

    # set turn to player X since X always plays first
    self.player_turn = 'X'

  # function to draw the board
  def draw_board(self):
    for i in range(0, 3):
      for j in range(0, 3):
        print('{}|'.format(self.current_state[i][j]), end=" ")
      print()
    print()

  # determines if the move is legal
  def is_valid(self, px, py):
      if px < 0 or px > 2 or py < 0 or py > 2:
          return False
      elif self.current_state[px][py] != '.':
          return False
      else:
          return True

  # checks if the game has ended and returns the winner in each case
  def is_end(self):
    # vertical win
    for i in range(0, 3):
      if (self.current_state[0][i] != '.' and
        self.current_state[0][i] == self.current_state[1][i] and
        self.current_state[1][i] == self.current_state[2][i]):
        return self.current_state[0][i]

    # horizontal win
    for i in range(0, 3):
      if (self.current_state[i] == ['X', 'X', 'X']):
          return 'X'
      elif (self.current_state[i] == ['O', 'O', 'O']):
          return 'O'

    # first diagonal win
    if (self.current_state[0][0] != '.' and
      self.current_state[0][0] == self.current_state[1][1] and
      self.current_state[0][0] == self.current_state[2][2]):
      return self.current_state[0][0]

    # second diagonal win
    if (self.current_state[0][2] != '.' and
      self.current_state[0][2] == self.current_state[1][1] and
      self.current_state[0][2] == self.current_state[2][0]):
      return self.current_state[0][2]

    # is whole board full?
    for i in range(0, 3):
      for j in range(0, 3):
        # there's an empty field, we continue the game
        if (self.current_state[i][j] == '.'):
          return None

    # it's a tie!
    return '.'

  # player 'O' is max, in this case AI
  def max_alpha_beta(self, alpha, beta):
    maxv = -2
    px = None
    py = None

    result = self.is_end()

    if result == 'X':
        return (-1, 0, 0)
    elif result == 'O':
        return (1, 0, 0)
    elif result == '.':
        return (0, 0, 0)

    for i in range(0, 3):
      for j in range(0, 3):
        if self.current_state[i][j] == '.':
          self.current_state[i][j] = 'O'
          (m, min_i, in_j) = self.min_alpha_beta(alpha, beta)
          if m > maxv:
            maxv = m
            px = i
            py = j
          self.current_state[i][j] = '.'

          # two if statements - only difference
          if maxv >= beta:
            return (maxv, px, py)
          if maxv > alpha:
            alpha = maxv

    return (maxv, px, py)

  # player 'X' is min, in this case human
  def min_alpha_beta(self, alpha, beta):
    minv = 2

    qx = None
    qy = None

    result = self.is_end()
    if result == 'X':
      return (-1, 0, 0)
    elif result == 'O':
      return (1, 0, 0)
    elif result == '.':
      return (0, 0, 0)

    for i in range(0, 3):
      for j in range(0, 3):
        if self.current_state[i][j] == '.':
          self.current_state[i][j] = 'X'
          (m, max_i, max_j) = self.max_alpha_beta(alpha, beta)
          if m < minv:
            minv = m
            qx = i
            qy = j
          self.current_state[i][j] = '.'

          if minv <= alpha:
            return (minv, qx, qy)
          if minv < beta:
            beta = minv

    return (minv, qx, qy)


  def play_alpha_beta(self):
    while True:
      self.draw_board()
      self.result = self.is_end()

      if self.result != None:
        if self.result == 'X':
            print('The winner is X!')
        elif self.result == 'O':
            print('The winner is O!')
        elif self.result == '.':
            print("It's a tie!")
            
        self.initialize_game()
        return

      if self.player_turn == 'X':
        while True:
          start = time.time()
          (m, qx, qy) = self.min_alpha_beta(-2, 2)
          end = time.time()
          print('Evaluation time: {}s'.format(round(end - start, 7)))
          print('Recommended move: X = {}, Y = {}'.format(qx, qy))

          px = int(input('Insert the X coordinate: '))
          py = int(input('Insert the Y coordinate: '))

          qx = px
          qy = py

          if self.is_valid(px, py):
            self.current_state[px][py] = 'X'
            self.player_turn = 'O'
            break
          else:
            print('The move is not valid! Try again.')

      else:
        (m, px, py) = self.max_alpha_beta(-2, 2)
        self.current_state[px][py] = 'O'
        self.player_turn = 'X'

def main():
    g = Game_AB()
    g.play_alpha_beta()

if __name__ == "__main__":
    main()

"""EXPECTIMINIMAX

"""

#node.right and node.left, node.value

function expectiminimax(node, depth)
    if node is a terminal node or depth = 0
        return the heuristic value of node


    if the adversary is to play at node
        // Return value of minimum-valued child node
        let α := +∞
        foreach child of node
            α := min(α, expectiminimax(child, depth-1))
    else if we are to play at node
        // Return value of maximum-valued child node
        let α := -∞
        foreach child of node
            α := max(α, expectiminimax(child, depth-1))
    else if random event at node
        // Return weighted average of all child nodes' values
        let α := 0
        foreach child of node
            α := α + (Probability[child] × expectiminimax(child, depth-1))
    return α

def expectiminimax(node, is_max, is_chance):
  #Condition for terminal node
  #node.right and node.left
  if (node.left == None and node.right == None):
    return node.value
  
  #Chance node: Retu the average of the left and right sub-trees
  if (is_chance):
    return (expectiminimax(node.left, is_max, False) + expectiminimax(node.right, is_max, False))

  #Maximizer Node: Choose the mac from the left and right substrees
  if(is_max):
    return max(expectiminimax(node.left, True, False) , expectiminimax(node.right, True, False))

  else:
    #We are at a min 
    return min(expectiminimax(node.left, False, False) , expectiminimax(node.right, False, False))

"""Constraint Satisfaction Problems (CSP's)"""